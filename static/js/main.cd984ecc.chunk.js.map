{"version":3,"sources":["helper.js","Stores/Flipbook.js","matrix.js","computed.js","components/Flipbook.js","App.js","serviceWorker.js","index.js"],"names":["easeIn","x","Math","pow","easeInOut","easeOut","pageUrl","page","pages","memoize","displayedPages","viewWidth","xMargin","rightPage","maxX","leftPage","minX","imageWidth","pageScale","round","imageHeight","pageWidth","console","log","viewHeight","pageHeight","currentCenterOffset","initPages","url","id","FlipBookContainer","state","Container","window","thaycacac","Matrix","arg","Array","isArray","this","m","identity","multiply","y","translate","z","translateZ","deg","rotateY","toString","IE","test","navigator","userAgent","gloss","makePolygonArray","face","flip","spaceTop","setMinX","setMaxX","ax","bgImg","bgPos","dRadian","dRotate","direction","gx","i","image","j","lighting","originRight","pageRotation","pageTransform","polygonWidth","progress","rad","radian","radius","results","rotate","tfString","theta","transform","frontImage","backImage","PI","Infinity","sin","cos","computeX","computeLighting","push","abs","rot","ambient","blackness","diffuse","gradients","lightingPoints","specular","map","d","max","join","_canFlipLeft","currentPage","_canFlipRight","nPages","_polygonWidth","w","ceil","_polygonHeight","_polygonBgSize","_polygonArray","concat","Flipbook","flipDuration","useState","length","setDisplayedPages","setNImageLoad","setNImageLoadTrigger","imageLoadCallback","setImageLoadCallback","setCurrentPage","touchStartX","setTouchStartX","touchStartY","setTouchStartY","hasPointerEvents","preloadedImages","auto","setFlip","canFlipLeft","canFlipRight","polygonArray","polygonBgSize","polygonHeight","useEffect","onResize","preloadImages","setState","flipStart","a","requestAnimationFrame","flipAuto","ease","animate","duration","startRatio","t0","Date","now","ratio","t","onImageLoad","trigger","cb","didLoadImage","ev","swipeEnd","touch","flipRevert","onMouseDown","which","pageX","pageY","onMouseMove","swipeMove","img","ref","ref1","Object","keys","Image","src","to","flipBookContainer","onMouseUp","style","width","height","margin","className","left","top","onLoad","$event","item","index","backgroundImage","backgroundSize","backgroundPosition","zIndex","App","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.cd984ecc.chunk.js","sourcesContent":["import memoize from 'lodash/memoize'\n\nexport const easeIn = x => Math.pow(x, 2);\n\nexport const easeOut = x => 1 - easeIn(1 - x);\n\nexport const easeInOut = function(x) {\n  if (x < 0.5) { return easeIn(x * 2) / 2; } else { return 0.5 + (easeOut((x - 0.5) * 2) / 2); }\n};\n\nconst pageUrl = (page, pages) => {\n  return pages[page] || null\n}\n\nconst boundingRight = (displayedPages, viewWidth, xMargin, rightPage, maxX, pages) => {\n  if (displayedPages === 1) { return viewWidth - xMargin }\n  else {\n      const x = pageUrl(rightPage, pages) ? viewWidth - xMargin : viewWidth / 2\n      return x > maxX ? x : maxX\n  }\n}\n\nconst boundingLeft = (displayedPages, viewWidth, xMargin, leftPage, minX, pages) => {\n  if (displayedPages === 1) { return xMargin }\n  else {\n      const x = pageUrl(leftPage, pages) ? xMargin : viewWidth / 2\n      return x < minX ? x : minX \n  }\n}\n\nconst pageWidth = (imageWidth, pageScale) => {\n  return Math.round(imageWidth * pageScale)\n}\n\nconst pageHeight = (imageHeight, pageScale) => Math.round(imageHeight * pageScale)\n\nconst xMargin = (viewWidth, pageWidth, displayedPages) => {\n  console.log('xMargin', viewWidth, pageWidth, displayedPages);\n  return (viewWidth - pageWidth * displayedPages) / 2\n}\n\nconst yMargin = (viewHeight, pageHeight) => (viewHeight - pageHeight) / 2\n\nconst centerOffsetSmoothed = (currentCenterOffset) => Math.round(currentCenterOffset)\n\nexport const _pageUrl = memoize(pageUrl)\nexport const _boundingRight = memoize(boundingRight)\nexport const _boundingLeft = memoize(boundingLeft)\nexport const _pageWidth = memoize(pageWidth)\nexport const _pageHeight = memoize(pageHeight)\nexport const _xMargin = memoize(xMargin)\nexport const _yMargin = memoize(yMargin)\nexport const _centerOffsetSmoothed = memoize(centerOffsetSmoothed)\n","import { Container } from \"unstated\"\n\nconst initPages = [\n  null,\n  {\n    url: \"images/1.jpg\",\n    id: '8182045543'\n  },\n  {\n    url: \"images/2.jpg\",\n    id: \"4591469984\"\n  },\n  {\n    url: \"images/3.jpg\",\n    id: \"3816263638\"\n  },\n  {\n    url: \"images/4.jpg\",\n    id: \"7912047691\"\n  },\n  {\n    url: \"images/5.jpg\",\n    id: \"4944943318\"\n  },\n  {\n    url: \"images/6.jpg\",\n    id: \"3800999370\"\n  }\n];\n\nclass FlipBookStore extends Container {\n  state = {\n    pageWidth: 640,\n    pageHeight: 906,\n    pages: initPages,\n    leftPage: 0,\n    rightPage: 1\n  };\n}\n\nconst FlipBookContainer = new FlipBookStore();\n\nexport default FlipBookContainer;\nwindow.thaycacac = FlipBookContainer;\n","import {\n  identity,\n  multiply,\n  translate,\n  translateZ,\n  rotateY\n} from 'rematrix';\n\nexport default class Matrix {\n  constructor(arg) {\n    if (arg) {\n      if (Array.isArray(arg)) {\n        this.m = arg;\n      } else {\n        this.m = [...arg.m];\n      }\n    } else {\n      this.m = identity();\n    }\n  }\n\n  multiply(m) {\n    if (!Array.isArray(m)) {\n      m = m.m;\n    }\n    return this.m = multiply(this.m, m);\n  }\n\n  computeX() {\n    return this.m[12];\n  }\n\n  translate(x, y) {\n    return this.multiply(translate(x, y));\n  }\n\n  translateZ(z) {\n    return this.multiply(translateZ(z));\n  }\n\n  rotateY(deg) {\n    return this.multiply(rotateY(deg));\n  }\n\n  toString() {\n    return `matrix3d(${this.m.toString()})`;\n  }\n\n};","import memoize from 'lodash/memoize'\nimport Matrix from './matrix'\n\nconst IE = /Trident/.test(navigator.userAgent)\nconst gloss = 0.6\nconst nPolygons = 10\nconst perspective = '2400px'\n\nconst pageUrl = (pages, page) => {\n  if (!pages[page]) return null\n  // if (!pages[page].url) return default\n  return pages[page].url || null;\n}\n\nconst canFlipLeft = (flip, currentPage, displayedPages, leftPage, pages) => {\n  return (\n    !flip.direction &&\n    (currentPage >= displayedPages) &&\n    !(displayedPages === 1 && !pageUrl(pages, leftPage - 1))\n  )\n}\n\n\nconst canFlipRight = (flip, currentPage, nPages, displayedPages) => {\n  return !flip.direction && currentPage < nPages - displayedPages\n}\n\nconst polygonWidth = pageWidth => {\n  var w;\n  w = pageWidth / nPolygons;\n  w = Math.ceil(w + 1);\n  return w + 'px';\n}\n\nconst polygonHeight = pageHeight => {\n  return pageHeight + 'px';\n}\n\nconst polygonBgSize = (pageWidth, pageHeight) => {\n  return `${pageWidth}px ${pageHeight}px`;\n}\n\nconst makePolygonArray = (face, flip, displayedPages, pageWidth, xMargin, spaceTop, minX, maxX, setMinX, setMaxX) => {\n  var ax,\n      bgImg,\n      bgPos,\n      dRadian,\n      dRotate,\n      direction,\n      gx,\n      i,\n      image,\n      j,\n      lighting,\n      originRight,\n      pageRotation,\n      pageTransform,\n      polygonWidth,\n      progress,\n      rad,\n      radian,\n      radius,\n      ref,\n      results,\n      rotate,\n      tfString,\n      theta,\n      transform,\n      x,\n      z;\n  if (!flip.direction) {\n    return [];\n  }\n  progress = flip.progress;\n  direction = flip.direction;\n  if (displayedPages === 1 && direction === 'left') {\n    progress = 1 - progress;\n    direction = 'right';\n  }\n  image = face === 'front' ? flip.frontImage : flip.backImage;\n  bgImg = image && `url('${image}')`;\n  polygonWidth = pageWidth / nPolygons;\n  gx = xMargin;\n  originRight = false;\n  if (displayedPages === 1) {\n    if (face === 'back') {\n      originRight = true;\n      gx = xMargin - pageWidth;\n    }\n  } else {\n    if (direction === 'left') {\n      if (face === 'back') {\n        gx = pageWidth;\n      } else {\n        originRight = true;\n      }\n    } else {\n      if (face === 'front') {\n        gx = pageWidth;\n      } else {\n        originRight = true;\n      }\n    }\n  }\n  pageTransform = new Matrix();\n  pageTransform.translate(gx, spaceTop);\n  pageRotation = 0;\n  if (progress > 0.5) {\n    pageRotation = -(progress - 0.5) * 2 * 180;\n  }\n  if (direction === 'left') {\n    pageRotation = -pageRotation;\n  }\n  if (face === 'back') {\n    pageRotation += 180;\n  }\n  if (pageRotation) {\n    if (originRight) {\n      pageTransform.translate(pageWidth);\n    }\n    pageTransform.rotateY(pageRotation);\n    if (originRight) {\n      pageTransform.translate(-pageWidth);\n    }\n  }\n  if (progress < 0.5) {\n    theta = progress * 2 * Math.PI;\n  } else {\n    theta = (1 - (progress - 0.5) * 2) * Math.PI;\n  }\n  if (theta === 0) {\n    theta = 1e-9;\n  }\n  radius = pageWidth / theta;\n  radian = 0;\n  dRadian = theta / nPolygons;\n  rotate = dRadian / 2 / Math.PI * 180;\n  dRotate = dRadian / Math.PI * 180;\n  if (originRight) {\n    rotate = -theta / Math.PI * 180 + dRotate / 2;\n  }\n  if (face === 'back') {\n    rotate = -rotate;\n    dRotate = -dRotate;\n  }\n  setMinX(Infinity)\n  setMaxX(-Infinity)\n  results = [];\n  for (i = j = 0, ref = nPolygons; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {\n    bgPos = `${i / (nPolygons - 1) * 100}% 0px`;\n    transform = new Matrix(pageTransform);\n    rad = originRight ? theta - radian : radian;\n    x = Math.sin(rad) * radius;\n    if (originRight) {\n      x = pageWidth - x;\n    }\n    z = (1 - Math.cos(rad)) * radius;\n    if (face === 'back') {\n      z = -z;\n    }\n    transform.translate(x);\n    transform.translateZ(z);\n    transform.rotateY(-rotate);\n    ax = transform.computeX();\n    if (ax > maxX) {\n      setMaxX(ax)\n    }\n    ax += 2 * polygonWidth;\n    if (ax < minX) {\n      setMinX(ax)\n    }\n    lighting = computeLighting(pageRotation - rotate, dRotate);\n    tfString = `perspective(${perspective}) ${transform.toString()}`;\n    radian += dRadian;\n    rotate += dRotate;\n    results.push([face + i, bgImg, lighting, bgPos, tfString, Math.abs(Math.round(z))]);\n  }\n  return results;\n};\n\nconst computeLighting = (rot, dRotate, ambient) => {\n  var DEG, POW, blackness, diffuse, gradients, lightingPoints, specular;\n  gradients = [];\n  lightingPoints = [-0.5, -0.25, 0, 0.25, 0.5];\n  if (ambient < 1) {\n    blackness = 1 - ambient;\n    diffuse = lightingPoints.map((d) => {\n      return (1 - Math.cos((rot - dRotate * d) / 180 * Math.PI)) * blackness;\n    });\n    gradients.push(`linear-gradient(to right,\n      rgba(0, 0, 0, ${diffuse[0]}),\n      rgba(0, 0, 0, ${diffuse[1]}) 25%,\n      rgba(0, 0, 0, ${diffuse[2]}) 50%,\n      rgba(0, 0, 0, ${diffuse[3]}) 75%,\n      rgba(0, 0, 0, ${diffuse[4]}))`);\n  }\n  if (gloss > 0 && !IE) {\n    DEG = 30;\n    POW = 200;\n    specular = lightingPoints.map((d) => {\n      return Math.max(Math.cos((rot + DEG - dRotate * d) / 180 * Math.PI) ** POW, Math.cos((rot - DEG - dRotate * d) / 180 * Math.PI) ** POW);\n    });\n    gradients.push(`linear-gradient(to right,\n      rgba(255, 255, 255, ${specular[0] * gloss}),\n      rgba(255, 255, 255, ${specular[1] * gloss}) 25%,\n      rgba(255, 255, 255, ${specular[2] * gloss}) 50%,\n      rgba(255, 255, 255, ${specular[3] * gloss}) 75%,\n      rgba(255, 255, 255, ${specular[4] * gloss}))`);\n  }\n  return gradients.join(',');\n};\n\nconst polygonArray = (flip, displayedPages, pageWidth, xMargin, spaceTop, minX, maxX, setMinX, setMaxX) => {\n  return makePolygonArray('front', flip, displayedPages, pageWidth, xMargin, spaceTop, minX, maxX, setMinX, setMaxX)\n    .concat(makePolygonArray('back', flip, displayedPages, pageWidth, xMargin, spaceTop, minX, maxX, setMinX, setMaxX))\n}\n\nexport const _canFlipLeft = memoize(canFlipLeft)\nexport const _canFlipRight = memoize(canFlipRight)\nexport const _polygonWidth = memoize(polygonWidth)\nexport const _polygonHeight = memoize(polygonHeight)\nexport const _polygonBgSize = memoize(polygonBgSize)\nexport const _polygonArray = memoize(polygonArray)\n","import React, { useState, useEffect } from \"react\"\nimport { easeInOut } from \"../helper\"\nimport { Subscribe } from \"unstated\"\nimport FlipBookContainer from \"../Stores/Flipbook\";\nimport {\n  _canFlipLeft,\n  _canFlipRight,\n  _polygonArray,\n  _polygonBgSize,\n  _polygonHeight,\n  _polygonWidth\n} from '../computed'\nimport \"./Styles.css\"\n\nconst Flipbook = ({\n  flipDuration = 1000,\n  spaceTop = 0\n}) => {\n  const flipInit = {\n    progress: 0,\n    direction: null,\n    frontImage: null,\n    backImage: null,\n    auto: false\n  }\n\n  const {\n    pageWidth,\n    pageHeight,\n    pages,\n    leftPage,\n    rightPage\n  } = FlipBookContainer.state\n\n  const [nPages, setNPages] = useState(pages.length);\n  const [displayedPages, setDisplayedPages] = useState(1);\n  const [nImageLoad, setNImageLoad] = useState(0);\n  const [nImageLoadTrigger, setNImageLoadTrigger] = useState(0);\n  const [imageLoadCallback, setImageLoadCallback] = useState(null);\n  const [currentPage, setCurrentPage] = useState(0);\n  const [touchStartX, setTouchStartX] = useState(null);\n  const [touchStartY, setTouchStartY] = useState(null);\n  const [hasPointerEvents, setHasPointerEvents] = useState(false);\n  const [minX, setMinX] = useState(Infinity);\n  const [maxX, setMaxX] = useState(-Infinity);\n  const [preloadedImages, setPreloadedImages] = useState({});\n  const [flip, setFlip] = useState(flipInit);\n  const [xMargin, setXMargin] = useState(0) // this.pageWidth * 2 - this.pageWidth * this.displayedPages) / 2\n  // computed\n  const canFlipLeft = _canFlipLeft(flip, currentPage, displayedPages, leftPage, pages)\n  const canFlipRight = _canFlipRight(flip, currentPage, nPages, displayedPages)\n  const polygonArray = _polygonArray(flip, displayedPages, pageWidth, xMargin, spaceTop, minX, maxX, setMinX, setMaxX)\n  const polygonBgSize = _polygonBgSize(pageWidth, pageHeight)\n  const polygonWidth = _polygonWidth(pageWidth)\n  const polygonHeight = _polygonHeight(pageHeight)\n\n  useEffect(() => {\n    onResize();\n    preloadImages();\n  }, []);\n\n  useEffect(() => {\n    FlipBookContainer.setState({\n      leftPage: currentPage,\n      rightPage: currentPage + 1\n    })\n    preloadImages()\n  }, [currentPage])\n\n  // method\n  const onResize = () => {\n    setDisplayedPages(pageWidth * 2 > pageHeight ? 2 : 1)\n  }\n\n  const logEvery = () => {\n    console.log({\n      currentPage: currentPage,\n      displayedPages: displayedPages,\n      flip: flip,\n      hasPointerEvents: hasPointerEvents,\n      imageLoadCallback: imageLoadCallback,\n      leftPage: leftPage,\n      maxX: maxX,\n      minX: minX,\n      nImageLoad: nImageLoad,\n      nImageLoadTrigger: nImageLoadTrigger,\n      nPages: nPages,\n      pageHeight: pageHeight,\n      pageWidth: pageWidth,\n      preloadedImages: preloadImages,\n      rightPage: rightPage,\n      touchStartX: touchStartX,\n      touchStartY: touchStartY,\n      canFlipLeft: canFlipLeft,\n      canFlipRight: canFlipRight,\n      polygonArray: polygonArray,\n      polygonBgSize: polygonBgSize,\n      polygonWidth: polygonWidth,\n      polygonHeight: polygonHeight\n    });\n  }\n\n  const pageUrl = (page) => {\n    if (!pages[page]) return null\n    // if (!pages[page].url) return default\n    return pages[page].url || null;\n  }\n\n  const flipStart = async (direction, auto) => {\n    if (direction === 'left') {\n      if (displayedPages === 1) {\n        setFlip({\n          ...flip,\n          direction: direction,\n          frontImage: pageUrl(currentPage - 1),\n          backImage: null\n        })\n      } else {\n        setFlip({\n          ...flip,\n          direction: direction,\n          frontImage: pageUrl(leftPage),\n          backImage: pageUrl(currentPage - displayedPages + 1)\n        })\n      }\n    } else {\n      if (displayedPages === 1) {\n        setFlip({\n          ...flip,\n          direction: direction,\n          frontImage: pageUrl(currentPage),\n          backImage: null\n        })\n      } else {\n        setFlip({\n          ...flip,\n          direction: direction,\n          frontImage: pageUrl(rightPage),\n          backImage: pageUrl(currentPage + displayedPages)\n        })\n      }\n    }\n    return requestAnimationFrame(() => {\n      return requestAnimationFrame(() => {\n        if (direction === 'left') {\n          if (displayedPages === 2) {\n            FlipBookContainer.setState({\n              leftPage: currentPage - displayedPages\n            })\n          }\n        } else {\n          if (displayedPages === 1) {\n            FlipBookContainer.setState({\n              leftPage: currentPage + displayedPages\n            })\n          } else {  \n            FlipBookContainer.setState({\n              rightPage: currentPage + 1 + displayedPages\n            })\n          }\n        }\n        if (auto) {\n          return flipAuto(true);\n        }\n      });\n    });\n  }\n\n  const flipAuto = ease => {\n    var animate, duration, startRatio, t0;\n      t0 = Date.now();\n      duration = flipDuration * (1 - flip.progress);\n      startRatio = flip.progress;\n      setFlip({\n        ...flip,\n        auto: true\n      })\n      animate = () => {\n        return requestAnimationFrame(() => {\n          var ratio, t;\n          t = Date.now() - t0;\n          ratio = startRatio + t / duration;\n          if (ratio > 1) {\n            ratio = 1;\n          }\n          setFlip({\n            ...flip,\n            progress: ease ? easeInOut(ratio) : ratio\n          })\n          if (ratio < 1) {\n            return animate();\n          } else {\n            if (flip.direction === 'left') {\n              setCurrentPage(currentPage - displayedPages)\n            } else {\n              setCurrentPage(currentPage + displayedPages)\n            }\n            if (displayedPages === 1 && flip.direction === 'right') {\n              setFlip({\n                ...flip,\n                direction: null\n              })\n            } else {\n              onImageLoad(1, () => {\n                console.log('callback here');\n                setFlip({\n                  ...flip,\n                  direction: null,\n                  auto: false,\n                  progress: 0\n                })\n              });\n            }\n          }\n        });\n      };\n      return animate();\n  }\n\n  const flipRevert = () => {\n    var animate, duration, startRatio, t0;\n      t0 = Date.now();\n      duration = flipDuration * flip.progress;\n      startRatio = flip.progress;\n      setFlip({\n        ...flip,\n        auto: true\n      })\n      animate = () => {\n        return requestAnimationFrame(() => {\n          var ratio, t;\n          t = Date.now() - t0;\n          ratio = startRatio - startRatio * t / duration;\n          if (ratio < 0) {\n            ratio = 0;\n          }\n          setFlip({\n            ...flip,\n            progress: ratio\n          })\n          if (ratio > 0) {\n            return animate();\n          } else {\n            FlipBookContainer.setState({\n              leftPage: currentPage,\n              rightPage: currentPage + 1\n            })\n            if (displayedPages === 1 && flip.direction === 'left') {\n              setFlip({\n                ...flip,\n                direction: null,\n                auto: false\n              })\n            } else {\n              onImageLoad(1, () => {\n                setFlip({\n                  ...flip,\n                  direction: null,\n                  auto: false\n                })\n              });\n            }\n            return false;\n          }\n        });\n      };\n      return animate();\n  }\n\n  const onImageLoad = (trigger, cb) => {\n    setNImageLoad(0)\n    setNImageLoadTrigger(trigger)\n    setImageLoadCallback(cb)\n  }\n\n  const didLoadImage = ev => {\n    if (!imageLoadCallback) {\n      return;\n    }\n    imageLoadCallback()\n  }\n\n  const swipeStart = touch => {\n    setTouchStartX(touch.pageX);\n    setTouchStartY(touch.pageY);\n  }\n\n  const swipeMove = touch => {\n    var x, y;\n    if (touchStartX == null) {\n      return;\n    }\n    x = touch.pageX - touchStartX;\n    y = touch.pageY - touchStartY;\n    if (Math.abs(y) > Math.abs(x)) {\n      return;\n    }\n    if (x > 0) {\n      if (flip.direction === null && canFlipLeft && x >= 5) {\n        flipStart('left', false);\n      }\n      if (flip.direction === 'left') {\n        setFlip({\n          ...flip,\n          progress: x / pageWidth < 1 ? x / pageWidth : 1\n        })\n      }\n    } else {\n      if (flip.direction === null && canFlipRight && x <= -5) {\n        flipStart('right', false);\n      }\n      if (flip.direction === 'right') {\n        setFlip({\n          ...flip,\n          progress: -x / pageWidth < 1 ? -x / pageWidth : 1\n        })\n      }\n    }\n    return true;\n  }\n\n  const swipeEnd = touch => {\n    if (flip.direction !== null && !flip.auto) {\n      if (flip.progress > 1 / 4) {\n        flipAuto(false);\n      } else {\n        flipRevert();\n      }\n    }\n    setTouchStartX(null)\n    return null;\n  }\n\n  const onMouseDown = ev => {\n    if (hasPointerEvents) {\n      return;\n    }\n    if (ev.which && ev.which !== 1) {\n      return;\n    }\n    return swipeStart(ev);\n  }\n\n  const onMouseMove = ev => {\n    if (hasPointerEvents) {\n      return;\n    }\n    if (ev.which && ev.which !== 1) {\n      return;\n    } // Ignore right-click\n    return swipeMove(ev);\n  }\n\n  const onMouseUp = ev => {\n    if (!hasPointerEvents) {\n      return swipeEnd(ev)\n    }\n  }\n\n  const preloadImages = () => {\n    var i, img, j, ref, ref1, results, url;\n    if (Object.keys(preloadedImages).length >= 10) {\n      this.preloadedImages = {};\n    }\n    results = [];\n    for (i = j = ref = currentPage - 3, ref1 = currentPage + 3; (ref <= ref1 ? j <= ref1 : j >= ref1); i = ref <= ref1 ? ++j : --j) {\n      url = pageUrl(i);\n      if (url) {\n        if (!preloadedImages[url]) {\n          img = new Image();\n          img.src = url;\n          results.push(preloadedImages[url] = img);\n        } else {\n          results.push(void 0);\n        }\n      } else {\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  return (\n    <Subscribe to={[FlipBookContainer]}>\n      {flipBookContainer => {\n        const {\n          pageWidth,\n          pageHeight,\n          leftPage,\n          rightPage\n        } = flipBookContainer.state\n        return (\n          <div\n            onMouseDown={ev => onMouseDown(ev)}\n            onMouseMove={ev => onMouseMove(ev)}\n            onMouseUp={ev => onMouseUp(ev)}\n            style={{\n              width: pageWidth * displayedPages + 'px',\n              height: pageHeight + 'px',\n              margin: 'auto'  \n            }}\n          >\n            <div className=\"viewport\">\n            <div className=\"container\" style={{ width: '100%' }}>\n              <div\n                className=\"centering-box\"\n                style={{ width: pageWidth * displayedPages }}\n              >\n                { pageUrl(leftPage) && <img\n                  className=\"page fixed\"\n                  style={{\n                    width: pageWidth + 'px',\n                    height: pageHeight + 'px',\n                    left: xMargin + 'px',\n                    top: spaceTop + 'px'\n                  }}\n                  src={pageUrl(leftPage)}\n                  onLoad={($event) => didLoadImage($event)}\n                />}\n                { displayedPages === 2 && pageUrl(rightPage) && <img\n                  className=\"page fixed\"\n                  style={{\n                    width: pageWidth + 'px',\n                    height: pageHeight + 'px',\n                    left: pageWidth + 'px',\n                    top: spaceTop + 'px'\n                  }}\n                  src={pageUrl(rightPage)}\n                  onLoad={($event) => didLoadImage($event)}\n                />}\n                {\n                  polygonArray.map((item, index) => {\n                    return (\n                      <div\n                      key={ index }\n                      className={ item[1] ? 'polygon blank' : 'polygon'}\n                      style={{\n                        backgroundImage: item[1],\n                        backgroundSize: polygonBgSize,\n                        backgroundPosition: item[3],\n                        width: polygonWidth,\n                        height: polygonHeight,\n                        transform: item[4],\n                        zIndex: item[5]\n                      }}\n                      >\n                      {\n                        item[2].length && <div\n                          className=\"lighting\"\n                          style={{ backgroundImage: item[2] }}\n                        />\n                      }\n                      </div>\n                    )\n                  })\n                }\n                </div>\n                <div className=\"guard\" />\n              </div>\n            </div>\n          </div>\n        );\n      }}\n    </Subscribe>\n  );\n};\n\nexport default Flipbook;\n","import React, { useState } from \"react\";\nimport Flipbook from \"./components/Flipbook\";\nimport { Provider } from \"unstated\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <Provider>\n      <div id=\"app\">\n        <Flipbook/>\n      </div>\n    </Provider>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}